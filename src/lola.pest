// Status: WIP (Draft)


// Take a look at https://pest-parser.github.io/book/grammars/syntax.html
// TODO we can probably mark some rules as atomic or hidden

IncompleteSpec = { SOI ~ LanguageSpec? ~ Declaration* }
Spec = { SOI ~ LanguageSpec? ~ Declaration* ~ EOI }
LanguageSpec ={ "//!" ~("ClassicLola" | "Lola2.0" | "RTLola") }
Declaration = _{IncludeStatement | TypeDecl | ConstantStream | InputStream | OutputStream | Trigger}

//////////////////////////////////////////////////
/////////////////// Statements ///////////////////
//////////////////////////////////////////////////

ParamList = { "<"~ Ident ~ ":" ~ Type~ ("," ~Ident ~ ":" ~ Type)* ~">"}

TemplateSpec = { 
      "{" ~
        ("invoke" ~Expr ~("if" | "unless")~ Expr)? ~
        ("extend" ~Expr?~ ("@"~ Frequency)?)?~
        ("terminate" ~Expr)?~
      "}"}

IncludeStatement = { "include"~ StringLiteral}

TypeDecl = { "type"~ Ident ~"{" ~Ident~ ":"~Type~ ("," ~Ident~ ":"~Type)* ~ "}"}

ConstantStream = { "constant"~ Ident ~ (":" ~ Type)? ~":=" ~Literal}

InputStream = { "input" ~Ident ~ ParamList? ~ (":" ~ Type)? ~(","~ Ident~ ParamList? ~ ":" ~ Type)*}

OutputStream = { "output"~ Ident ~ ParamList?~ (":" ~ Type)? ~ TemplateSpec? ~":="~ Expr}

Trigger = { "trigger"~ (Ident ~ ":=")? ~ Expr~ StringLiteral?}

//////////////////////////////////////////////////
////////////////// Expressions ///////////////////
//////////////////////////////////////////////////

// TODO take a look at https://pest-parser.github.io/book/ and the usage of the PrecClimber

// Precedences:
// Atomic < TernaryExpr < BooleanDisExpr < BooleanConExpr 
//      < CompExpr < AddExpr < MultiExpr < ExpoExpr < UnaryExpr < DefaultExpr 
//      < FunctionExpr < LookupExpr < CompoundExpr

Operation = _{ Add | Subtract | Power | Multiply | Divide | Mod | And | Or | CompOp }
    Add      = { "+"  }
    Subtract = { "-"  }
    Multiply = { "*"  }
    Divide   = { "/"  }
    Mod      = { "%"  }
    Power    = { "**" }
    And      = { "∧" | "&"{1,2} | "and" }
    Or       = { "∨" | "|"{1,2} | "or"  }

UnaryOperation = _{ Add | Subtract | Neg }
    Neg      = { "!" | "¬" }

Expr = { Term ~ (Operation ~ Term)* }
// TODO Do we need Term to exist for the precedence climber?
Term = _{ Literal | ParenthesizedExpression | CompoundExpr | DefaultExpr| LookupExpr | FunctionExpr | UnaryExpr | TernaryExpr | MissingExpression | Ident | Tuple}

ParenthesizedExpression = {OpeningParenthesis ~ Expr ~ ClosingParenthesis | OpeningParenthesis ~ Expr ~ MissingClosingParenthesis}
OpeningParenthesis = {"("}
ClosingParenthesis = {")"}

MissingClosingParenthesis = {WHITESPACE* ~ &("then" | "else" |"output" | "input" | "trigger" | "constant" | "Type" | "include" | EOI)}
MissingExpression = {WHITESPACE* ~ &("then" | "else" |")"|"output" | "input" | "trigger" | "constant" | "Type" | "include" | EOI)}

CompoundExpr = {Ident~ "."~ Ident}

LookupExpr = {
      StreamInstance ~"["~ Expr~ "]" 
    | StreamInstance ~"["~ Duration ~"," ~WindowOp~ "]"
    | StreamInstance ~"["~ Duration~ "]"}

FunctionExpr = { 
      FunctionSymbol~ "(" ~Expr ~("," ~Expr)*~ ")" }

DefaultExpr = {
      LookupExpr~ "?"~ Expr}

UnaryExpr = {
      UnaryOperation~ Expr}

TernaryExpr = {
      "if"~ Expr~ "then"~ Expr~ "else"~ Expr}

Tuple = { "("~ (Expr~ (","~ Expr)+)?~ ")"}


//////////////////////////////////////////////////
//////////// Operators and Functions /////////////
//////////////////////////////////////////////////

LessThan = {"<"}
LessThanOrEqual = {"<=" | "≤"}
MoreThan = {">"}
MoreThanOrEqual = {">=" | "≥"}
NotEqual = {"!=" | "≠"}
Equal = {"="}
CompOp = _{LessThanOrEqual | MoreThanOrEqual | LessThan | MoreThan | NotEqual | Equal}

BinaryFunctionSymbol = {
      "nroot"
    | "π" // Tuple Projection
    }

UnaryFunctionSymbol = {
      "sin"
    | "cos"
    | "tan"
    | "arcsin"
    | "arccos"
    | "arctan"
    | "exp"
    | "floor"
    | "ceil"
    | "sqrt"
}

Sum = {"Σ" | "sum"}
Count = {"#"|"count"}
Product = {"Π" | "prod"}
Integral = {"∫"  | "integral"}
Average = { "avg" }

WindowOp = _{ Sum | Product | Average | Count | Integral}

FunctionSymbol = _{ UnaryFunctionSymbol | BinaryFunctionSymbol}


//////////////////////////////////////////////////
//////////////////// Literals ////////////////////
//////////////////////////////////////////////////

NumberLiteral = @{ ("+" | "-")?~ Digit+~ ("."~ Digit*)?~ ("e"~ ("+" | "-")?~ Digit*)?}

StringLiteral = _{ "\""~ String~ "\""}
String = @{("\\\""|!("\"") ~ ANY)*}

TupleLiteral = { "(" ~(Literal ~(","~ Literal)+)?~ ")"}
BooleanLiteral = _{ True | False}
True = @{"true"| "⊤"}
False = @{"false"  | "⊥"}
Literal = { StringLiteral | NumberLiteral | TupleLiteral | BooleanLiteral}

IntegerLiteral = @{ Digit*}

Type = {"("~ (Type ~(","~Type)*)?~ ")" | Ident}

//////////////////////////////////////////////////
////////////////// Time Related //////////////////
//////////////////////////////////////////////////

Duration = { Expr~ UnitOfTime}

UnitOfTime = { "ns" | "μs" | "ms" | "s" | "min" | "h" | "d" | "w" | "a" }

Frequency = { Duration | NumberLiteral ~UnitOfFreq}

UnitOfFreq = { "μHz" | "mHz" | "Hz" | "kHz" | "MHz"}


//////////////////////////////////////////////////
///////////////////// Names //////////////////////
//////////////////////////////////////////////////

Ident = @{  (Letter | "_") ~ (Letter | Digit | "_")*}

Parameter = { Ident} // Semantic Category

StreamInstance = { Ident ~("(" ~Expr ~(","~ Expr)* ~")")?}

//////////////////////////////////////////////////
//////////////////// Symbols /////////////////////
//////////////////////////////////////////////////

Letter = { 'a'..'z' | 'A'..'Z'}
Digit = _{'0'..'9'}
Number = { '0'..'9'+ }
WHITESPACE = _{ " " | "\t" | "\n"}
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~(!("\n")~ANY)*~ "\n"? ) }
