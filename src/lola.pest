// Status: WIP (Draft)


// Take a look at https://pest-parser.github.io/book/grammars/syntax.html
// TODO we can probably mark some rules as atomic or hidden

Spec = { SOI ~LanguageSpec? ~ Declaration* ~ EOI}
LanguageSpec ={ "//!" ~("ClassicLola" | "Lola2.0" | "RTLola") }
Declaration = _{IncludeStatement | TypeDecl | ConstantStream | InputStream | OutputStream | Trigger}

//////////////////////////////////////////////////
/////////////////// Statements ///////////////////
//////////////////////////////////////////////////

ParamList = { "<"~ Ident ~ ":" ~ Type~ ("," ~Ident ~ ":" ~ Type)* ~">"}

TemplateSpec = { 
      "{" ~
        ("invoke" ~Expr ~("if" | "unless")~ Expr)? ~
        ("extend" ~Expr?~ ("@"~ Frequency)?)?~
        ("terminate" ~Expr)?~
      "}"}

IncludeStatement = { "include"~ StringLiteral}

TypeDecl = { "Type"~ Ident ~"{" ~Type~ Ident~ ("," ~Type~ Ident)+ ~ "}"}

ConstantStream = { "constant"~ Ident ~ ":" ~ Type ~":=" ~Literal}

InputStream = { "input" ~Ident ~ ParamList? ~ ":" ~ Type ~(","~ Ident~ ParamList? ~ ":" ~ Type)*}

OutputStream = { "output"~ Ident ~ ParamList?~ ":" ~ Type ~ TemplateSpec? ~":="~ Expr}

Trigger = { "trigger"~ Ident?~ Expr~ StringLiteral?}

//////////////////////////////////////////////////
////////////////// Expressions ///////////////////
//////////////////////////////////////////////////

// TODO take a look at https://pest-parser.github.io/book/ and the usage of the PrecClimber

// Precedences:
// Atomic < TernaryExpr < BooleanDisExpr < BooleanConExpr 
//      < CompExpr < AddExpr < MultiExpr < ExpoExpr < UnaryExpr < DefaultExpr 
//      < FunctionExpr < LookupExpr < CompoundExpr

Operation = _{ Add | Subtract | Power | Multiply | Divide | Mod | And | Or }
    Add      = { "+"  }
    Subtract = { "-"  }
    Multiply = { "*"  }
    Divide   = { "/"  }
    Mod      = { "%"  }
    Power    = { "**" }
    And      = { "∧" | "&" | "and" }
    Or       = { "∨" | "|" | "or"  }

Expr = { Term ~ (Operation ~ Term)* }
// TODO Do we need Term to exist for the precedence climber?
Term = _{ Literal | "(" ~ Expr ~ ")" | CompoundExpr | DefaultExpr| LookupExpr | FunctionExpr | UnaryExpr | TernaryExpr | Ident | Tuple}


CompoundExpr = {Ident~ "."~ Ident}

LookupExpr = {
      StreamInstance ~"["~ EffectiveConstant~ "]" 
    | StreamInstance ~"["~ Duration ~"," ~WindowOp~ "]"
    | StreamInstance ~"["~ Duration~ "]"}

FunctionExpr = { 
      FunctionSymbol~ "(" ~Expr ~("," ~Expr)*~ ")" 
    | "π"~ "("~ IntegerLiteral ~","~ Ident~ ")"}

DefaultExpr = { 
      LookupExpr~ "?"~ Term}

UnaryExpr = {
      "+"~ Term
    | "-"~ Term
    | "!"~ Term}


TernaryExpr = {
      "if"~ Expr~ "then"~ Expr~ "else"~ Expr}  

Tuple = { "("~ (Expr~ (","~ Expr)+)?~ ")"}


//////////////////////////////////////////////////
//////////// Operators and Functions /////////////
//////////////////////////////////////////////////

LessThan = {"<"}
LessThanOrEqual = {"<=" | "≤"}
MoreThan = {">"}
MoreThanOrEqual = {">=" | "≥"}
NotEqual = {"!=" | "≠"}
Equal = {"="}
CompOp = {LessThanOrEqual | MoreThanOrEqual | LessThan | MoreThan | NotEqual | Equal}

BinaryFunctionSymbol = {
      "nroot"
    | "π" // Tuple Projection
    }

UnaryFunctionSymbol = {
      "sin"
    | "cos"
    | "tan"
    | "amrcsin"
    | "arccos"
    | "arctan"
    | "exp"
    | "floor"
    | "ceil"
    | "sqrt"
}

Sum = {"Σ" | "sum"}
Count = {"#"|"count"}
Product = {"Π" | "prod"}
Integral = {"∫"  | "integral"}

WindowOp = _{ Sum | Product | "avg" | Count | Integral}

FunctionSymbol = _{ UnaryFunctionSymbol | BinaryFunctionSymbol}


//////////////////////////////////////////////////
//////////////////// Literals ////////////////////
//////////////////////////////////////////////////

NumberLiteral = @{ ("+" | "-")?~ Digit+~ ("."~ Digit*)?~ ("e"~ ("+" | "-")?~ Digit*)?}

StringLiteral = _{ "\""~ String~ "\""}
String = @{("\\\""|!("\"") ~ ANY)*}

TupleLiteral = { "(" ~(Literal ~(","~ Literal)*)?~ ")"}
BooleanLiteral = _{ True | False}
True = @{"true"| "⊤"}
False = @{"false"  | "⊥"}
Literal = _{ StringLiteral | NumberLiteral | TupleLiteral | BooleanLiteral}

IntegerLiteral = @{ Digit*}

Type = {"("~ (Type ~(","~Type)*)?~ ")" | Ident}

//////////////////////////////////////////////////
////////////////// Time Related //////////////////
//////////////////////////////////////////////////

Duration = { NumberLiteral~ UnitOfTime}

UnitOfTime = { "ns" | "μs" | "ms" | "s" | "min" | "h" | "d" | "w"}

Frequency = { Duration | NumberLiteral ~UnitOfFreq}

UnitOfFreq = { "μHz" | "mHz" | "Hz" | "kHz" | "MHz"}


//////////////////////////////////////////////////
///////////////////// Names //////////////////////
//////////////////////////////////////////////////

Ident = @{  (Letter | "_") ~ (Letter | Digit | "_")*}

Parameter = { Ident} // Semantic Category

EffectiveConstant = _{ Parameter | Literal}

StreamInstance = { Ident ~("(" ~EffectiveConstant ~(","~ EffectiveConstant)* ~")")?}

//////////////////////////////////////////////////
//////////////////// Symbols /////////////////////
//////////////////////////////////////////////////

Letter = { 'a'..'z' | 'A'..'Z'}
Digit = _{'0'..'9'}
Number = { '0'..'9'+ }
WHITESPACE = _{ " " | "\t" | "\n"}
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~(!("\n")~ANY)*~ "\n"? ) }
